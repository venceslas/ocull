//
// just an idea of how I could use the library
// based on the Umbra API
//

#include <stdlib.h>
#include <ocull.hpp>


int main(int argc, char *argv[])
{
  
  /// Create a scene objects, which holds all geometrics data of the scene
  Ocull::Scene *myScene = Ocull::Scene::Create();
  
  // for each model of the scene, its vertices are provided..
  const Ocull::Model *model = myScene->insertModel( vertices, indices, 8, 24);

  // ..then, for each instance, their position.
  Ocull::Matrix4x4 worldMatrix;  
  for (int i=0; i<NUM_OBJECTS; ++i)
  {
    init_matrix( worldMatrix );    
    myScene->insertObject( model, worldMatrix, i, flags);
  }
  
  
  //--
  
  
  /// Specify the camera + frustum for the current frame
  Ocull::Frustum frustum( fov, aspectRatio, zNear, zFar);
  Ocull::Matrix4x4 viewMatrix = setViewMatrix(); //
  
  Ocull::Camera camera( frustum, viewMatrix);
    
  
  /// A Query object is used to perform visibility query to the scene
  /// it used an internal rasterizer, common for every Queries
  // the scene is given in initialization to allow optimization in future
  // version
  Ocull::Query *query = new Ocull::Query(myScene);
  
  
  /// Create the memory to retrieve the query output
  // the visibility query can provide two differents kind of results,
  // an OcclusionBuffer for individual tests (not used here) or the
  // list of visible objects' index
  const int objectCount = myScene->getObjectCount();
  int objectIdx[objectCount];  
  Ocull::IndexList indexList( objectIdx, objectCount);// 
  
  
  /// Run a visibility query on the scene for the actual view
  query->queryVisibility( camera, indexList, NULL);
  
  
  
  /// 4) Render visible geometry
  //int *pIndices = objects.getPtr();  
  for (int i=0; i<indexList.getSize(); ++i)
  {
    unsigned int id = myScene->getObject( objectIdx[i] );    
    draw_object( id );
  }
  
  
  //myScene->release();
  
  return EXIT_SUCCESS;
}
